"use client"

import { useState, useEffect } from "react"
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from "@/components/ui/card"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Button } from "@/components/ui/button"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Badge } from "@/components/ui/badge"
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { AlertCircle, CheckCircle2, Loader2 } from "lucide-react"

// --- Type Definitions ---

// Represents a single inventory item, including details about its supplier and assigned resource.
type InventoryItem = {
  id: number
  name: string
  item_type: string
  quantity: number
  unit: string
  capacity: number
  supplier_id: number | null // ID of the supplier, null if not supplied directly
  supplier_name: string | null // Name of the supplier
  resource_id: number | null // ID of the resource it's allocated to, null if unallocated
  resource_name: string | null // Name of the allocated resource
}

// Represents a supplier providing inventory items.
type Supplier = {
  id: number
  name: string
  supplier_type: string
  location: { lat: number; lng: number } // Geographic coordinates
}

// Represents a resource location (e.g., warehouse, distribution center).
type Resource = {
  id: number
  name: string
  resource_type: string
  capacity: number // Total capacity
  current_count: number // Current number of items it holds (used for utilization)
  location: { lat: number; lng: number } // Geographic coordinates
}

// --- Component Definition ---

/**
 * InventoryAllocation Component
 * Manages both manual and automated allocation of inventory items
 * from suppliers to resource locations.
 */
export default function InventoryAllocation() {
  // --- State Variables ---

  // Stores the list of all inventory items fetched from the API.
  const [inventoryItems, setInventoryItems] = useState<InventoryItem[]>([])
  // Stores the list of all suppliers fetched from the API.
  const [suppliers, setSuppliers] = useState<Supplier[]>([])
  // Stores the list of all resource locations fetched from the API.
  const [resources, setResources] = useState<Resource[]>([])

  // State for the manual allocation form.
  const [selectedSupplier, setSelectedSupplier] = useState<string>("") // ID of the selected supplier
  const [selectedResource, setSelectedResource] = useState<string>("") // ID of the selected resource
  const [selectedItem, setSelectedItem] = useState<string>("")       // ID of the selected inventory item
  const [quantity, setQuantity] = useState<string>("1")             // Quantity to allocate

  // Loading and result state for manual allocation.
  const [isAllocating, setIsAllocating] = useState(false) // Tracks if manual allocation is in progress
  const [allocationResult, setAllocationResult] = useState<{ success: boolean; message: string } | null>(null) // Stores the result message of the manual allocation

  // Loading and result state for automated (Hungarian) allocation.
  const [isRunningAlgorithm, setIsRunningAlgorithm] = useState(false) // Tracks if the optimization algorithm is running
  // Stores the suggested allocations generated by the backend algorithm.
  const [algorithmResults, setAlgorithmResults] = useState<
    { from: string; to: string; item: string; quantity: number }[]
  >([])

  // General loading and error state for the component.
  const [loading, setLoading] = useState(true) // Tracks initial data loading state
  const [error, setError] = useState<string | null>(null) // Stores any error message during data fetching

  // --- Effects ---

  // Fetches initial data (inventory, suppliers, resources) when the component mounts.
  useEffect(() => {
    async function fetchData() {
      try {
        setLoading(true) // Start loading indicator
        const token = localStorage.getItem('accessToken') // Get auth token
        const headers = {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }

        // Fetch inventory items
        const inventoryResponse = await fetch('/api/resource-management/inventory', { headers })
        if (!inventoryResponse.ok) {
          throw new Error('Failed to fetch inventory items')
        }
        const inventoryData = await inventoryResponse.json()
        // Format the raw inventory data into the InventoryItem type.
        const formattedInventoryItems = inventoryData.map((item: any) => ({
          id: item.id,
          name: item.name,
          item_type: item.item_type,
          quantity: item.quantity,
          unit: item.unit,
          capacity: item.capacity,
          supplier_id: item.supplier?.id || null,
          supplier_name: item.supplier?.name || null,
          resource_id: item.resource?.id || null,
          resource_name: item.resource?.name || null
        }))
        setInventoryItems(formattedInventoryItems)

        // Fetch suppliers
        const suppliersResponse = await fetch('/api/resource-management/suppliers', { headers })
        if (!suppliersResponse.ok) {
          throw new Error('Failed to fetch suppliers')
        }
        const suppliersData = await suppliersResponse.json()
        console.log('Suppliers data:', suppliersData) // Debug log

        // Format the raw supplier GeoJSON data into the Supplier type.
        const formattedSuppliers = suppliersData.features.map((feature: any) => {
          // Debug log for each feature
          console.log('Processing supplier feature:', feature)

          let location = { lat: 0, lng: 0 }
          // Safely extract location coordinates, handling potential errors or missing data.
          try {
            if (feature.geometry && Array.isArray(feature.geometry.coordinates)) {
              location = {
                lat: feature.geometry.coordinates[1], // GeoJSON is [lng, lat]
                lng: feature.geometry.coordinates[0]
              }
            } else {
              console.warn(`Missing or invalid geometry for supplier ${feature.properties.name}`)
            }
          } catch (err) {
            console.warn(`Error processing location for supplier ${feature.properties.name}:`, err)
          }

          return {
            id: feature.id,
            name: feature.properties.name,
            supplier_type: feature.properties.supplier_type,
            location
          }
        })
        setSuppliers(formattedSuppliers)

        // Fetch resources
        const resourcesResponse = await fetch('/api/resource-management/resources', { headers })
        if (!resourcesResponse.ok) {
          throw new Error('Failed to fetch resources')
        }
        const resourcesData = await resourcesResponse.json()
        console.log('Resources data:', resourcesData) // Debug log

        // Format the raw resource GeoJSON data into the Resource type.
        const formattedResources = resourcesData.features.map((feature: any) => {
          // Debug log for each feature
          console.log('Processing resource feature:', feature)

          let location = { lat: 0, lng: 0 }
          // Safely extract location coordinates.
          try {
            if (feature.geometry && Array.isArray(feature.geometry.coordinates)) {
              location = {
                lat: feature.geometry.coordinates[1], // GeoJSON is [lng, lat]
                lng: feature.geometry.coordinates[0]
              }
            } else {
              console.warn(`Missing or invalid geometry for resource ${feature.properties.name}`)
            }
          } catch (err) {
            console.warn(`Error processing location for resource ${feature.properties.name}:`, err)
          }

          return {
            id: feature.id,
            name: feature.properties.name,
            resource_type: feature.properties.resource_type,
            capacity: feature.properties.capacity,
            current_count: feature.properties.current_count,
            location
          }
        })
        setResources(formattedResources)

        setError(null) // Clear any previous errors on successful fetch
      } catch (err) {
        // Handle errors during data fetching.
        console.error('Error fetching data:', err)
        if (err instanceof Error) {
          setError(`Failed to load data: ${err.message}`)
        } else {
          setError('Failed to load data from the server')
        }
      } finally {
        setLoading(false) // Stop loading indicator regardless of success or failure
      }
    }

    fetchData() // Execute the fetch function
  }, []) // Empty dependency array means this effect runs only once on mount

  // --- Event Handlers ---

  /**
   * Handles the submission of the manual allocation form.
   * Sends a request to the backend to allocate a specific quantity
   * of an inventory item to a selected resource.
   */
  const handleManualAllocation = async () => {
    // Basic validation
    if (!selectedSupplier || !selectedResource || !selectedItem || !quantity) {
      setAllocationResult({
        success: false,
        message: "Please fill in all fields",
      })
      return
    }

    setIsAllocating(true) // Set loading state for the button
    setAllocationResult(null) // Clear previous results

    try {
      const token = localStorage.getItem('accessToken')
      // Call the backend API endpoint for manual allocation.
      const response = await fetch('/api/resource-management/inventory/allocate/', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          inventory_item_id: Number.parseInt(selectedItem), // Ensure IDs are numbers
          resource_id: Number.parseInt(selectedResource),
          quantity: Number.parseInt(quantity) // Ensure quantity is a number
        })
      })

      // Handle API errors.
      if (!response.ok) {
        const errorText = await response.text()
        let errorMessage = 'Failed to allocate inventory'
        try {
          const errorData = JSON.parse(errorText) // Try to parse backend error message
          errorMessage = errorData.error || errorMessage
        } catch (e) {
          // Fallback if error response is not JSON
          console.error('Error parsing error response:', errorText)
        }
        throw new Error(errorMessage)
      }

      const result = await response.json() // Get success message from backend

      // --- Refresh inventory data after successful allocation ---
      const inventoryResponse = await fetch('/api/resource-management/inventory/', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      })
      if (!inventoryResponse.ok) {
        // Note: Allocation succeeded, but refresh failed. Inform user but don't revert state.
        throw new Error('Allocation successful, but failed to refresh inventory data. Please refresh manually.')
      }
      const inventoryData = await inventoryResponse.json()
      const formattedInventoryItems = inventoryData.map((item: any) => ({
        // (Same mapping logic as in useEffect)
        id: item.id,
        name: item.name,
        item_type: item.item_type,
        quantity: item.quantity,
        unit: item.unit,
        capacity: item.capacity,
        supplier_id: item.supplier?.id || null,
        supplier_name: item.supplier?.name || null,
        resource_id: item.resource?.id || null,
        resource_name: item.resource?.name || null
      }))
      setInventoryItems(formattedInventoryItems) // Update the state with refreshed data
      // --- End Refresh ---

      // Set success message
      setAllocationResult({
        success: true,
        message: result.message
      })

      // Reset form fields after successful allocation
      setSelectedItem("")
      setQuantity("1")
      // Optionally reset supplier/resource, or keep them selected for multiple allocations
      // setSelectedSupplier("")
      // setSelectedResource("")

    } catch (err) {
      // Handle errors during the allocation process.
      console.error('Error allocating inventory:', err)
      setAllocationResult({
        success: false,
        message: err instanceof Error ? err.message : 'Failed to allocate inventory'
      })
    } finally {
      setIsAllocating(false) // Stop loading indicator for the button
    }
  }

  /**
   * Runs the Hungarian algorithm on the backend to get optimized
   * allocation suggestions for unallocated inventory items.
   */
  const runHungarianAlgorithm = async () => {
    setIsRunningAlgorithm(true) // Set loading state for the button
    setAlgorithmResults([]) // Clear previous results
    setAllocationResult(null) // Clear previous messages

    try {
      const token = localStorage.getItem('accessToken')
      if (!token) {
        throw new Error('Authentication required. Please log in.')
      }

      // --- Prepare data for the backend ---
      // Filter items that are not yet assigned to a resource and have a supplier.
      const unallocatedItems = inventoryItems.filter(item => !item.resource_id && item.supplier_id)
      // Filter resources that have available capacity.
      const availableResources = resources.filter(resource => resource.current_count < resource.capacity)
      // Find suppliers who provide the unallocated items.
      const relevantSuppliers = suppliers.filter(supplier =>
        unallocatedItems.some(item => item.supplier_id === supplier.id)
      )

      // --- Basic validation before sending ---
      if (unallocatedItems.length === 0) {
        throw new Error('No unallocated items available for optimization')
      }
      if (availableResources.length === 0) {
        throw new Error('No available resources with capacity for allocation')
      }
      if (relevantSuppliers.length === 0) {
        // This might happen if unallocated items have supplier IDs not present in the fetched suppliers list
        throw new Error('No suppliers found matching the unallocated items')
      }

      // Format resource data to include location, needed for backend distance calculations.
      const formattedResources = availableResources.map(resource => ({
        id: resource.id,
        name: resource.name,
        resource_type: resource.resource_type,
        capacity: resource.capacity,
        current_count: resource.current_count,
        location: resource.location // Pass lat/lng
      }))

      // Log data being sent for debugging purposes.
      console.log('Sending data to optimize_allocation:', {
        items: unallocatedItems,
        resources: formattedResources,
        suppliers: relevantSuppliers
      })
      // --- End Prepare Data ---

      // Call the backend API endpoint to run the optimization.
      const response = await fetch('/api/resource-management/inventory/optimize_allocation', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          items: unallocatedItems,
          resources: formattedResources,
          suppliers: relevantSuppliers // Send relevant suppliers
        })
      })

      // Handle API errors.
      if (!response.ok) {
        const errorData = await response.json().catch(() => null) // Try parsing error JSON
        throw new Error(errorData?.error || `Failed to run optimization algorithm: ${response.statusText}`)
      }

      const results = await response.json() // Get the allocation suggestions

      // Check if the backend indicated success but returned an error message.
      if (results.success === false) {
        throw new Error(results.error || 'Optimization algorithm failed on the server')
      }

      // Store the suggested allocations.
      setAlgorithmResults(results.allocations || [])
      setAllocationResult({
        success: true,
        message: 'Successfully generated allocation recommendations'
      })

      // Note: We don't automatically refresh inventory here. The user needs to click "Apply".
      // Refreshing inventory could be confusing as the items are not *actually* allocated yet.

    } catch (err) {
      // Handle errors during the optimization process.
      console.error('Error running optimization algorithm:', err)
      setAllocationResult({
        success: false,
        message: err instanceof Error ? err.message : 'Failed to run optimization algorithm'
      })
      setAlgorithmResults([]) // Clear results on error
    } finally {
      setIsRunningAlgorithm(false) // Stop loading indicator for the button
    }
  }

  /**
   * Applies the allocation suggestions generated by the Hungarian algorithm.
   * Sends the suggested allocations back to the backend to update the database.
   */
  const applyAlgorithmResults = async () => {
    setAllocationResult(null) // Clear previous messages

    try {
      const token = localStorage.getItem('accessToken')
      // Call the backend API endpoint to apply the suggested allocations.
      const response = await fetch('/api/resource-management/inventory/apply-optimization/', { // Endpoint corrected
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          // Send the results obtained from runHungarianAlgorithm
          allocations: algorithmResults.map(res => ({
            // Map frontend results to the format expected by apply_optimization (item_id, resource_id)
            item_id: inventoryItems.find(item => item.name === res.item && !item.resource_id)?.id, // Find ID based on name (fragile if names aren't unique)
            resource_id: resources.find(r => r.name === res.to)?.id, // Find ID based on name
            // Include other data if needed by backend, but core are IDs
          })).filter(a => a.item_id && a.resource_id) // Filter out any allocations where IDs couldn't be found
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Failed to apply optimized allocations' }))
        throw new Error(errorData.error || errorData.message || 'Failed to apply optimized allocations');
      }

      const applyResult = await response.json();
       if (applyResult.success === false) {
        // Handle partial success or specific errors returned by the backend
        throw new Error(applyResult.message || 'Applying allocations failed on the server.');
      }

      // --- Refresh inventory data after successful application ---
      const inventoryResponse = await fetch('/api/resource-management/inventory', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      })
      if (!inventoryResponse.ok) {
        throw new Error('Allocations applied, but failed to refresh inventory data. Please refresh manually.')
      }
      const inventoryData = await inventoryResponse.json()
      const formattedInventoryItems = inventoryData.map((item: any) => ({
         // (Same mapping logic as in useEffect)
        id: item.id,
        name: item.name,
        item_type: item.item_type,
        quantity: item.quantity,
        unit: item.unit,
        capacity: item.capacity,
        supplier_id: item.supplier?.id || null,
        supplier_name: item.supplier?.name || null,
        resource_id: item.resource?.id || null,
        resource_name: item.resource?.name || null
      }))
      setInventoryItems(formattedInventoryItems) // Update state with refreshed data
      // --- End Refresh ---

      // Set success message and clear the suggested results list
      setAllocationResult({
        success: true,
        message: applyResult.message || "Successfully applied automated allocations"
      })
      setAlgorithmResults([]) // Clear the suggestions table

    } catch (err) {
      // Handle errors during the application process.
      console.error('Error applying optimized allocations:', err)
      setAllocationResult({
        success: false,
        message: err instanceof Error ? err.message : 'Failed to apply optimized allocations'
      })
    }
    // No 'finally' loading state needed here as it's triggered by the results table button
  }

  // --- Render Logic ---

  // Display loading spinner while fetching initial data.
  if (loading) {
    return (
      <Card>
        <CardContent className="flex items-center justify-center min-h-[200px]">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </CardContent>
      </Card>
    )
  }

  // Display error message if data fetching failed.
  if (error) {
    return (
      <Card>
        <CardContent className="p-6">
          <div className="text-red-500 text-center">
            <p className="font-semibold">Error</p>
            <p className="text-sm">{error}</p>
          </div>
        </CardContent>
      </Card>
    )
  }

  // Main component render
  return (
    // Tabs for switching between Manual and Automated allocation modes.
    <Tabs defaultValue="manual">
      <TabsList className="grid w-full grid-cols-2">
        <TabsTrigger value="manual">Manual Allocation</TabsTrigger>
        <TabsTrigger value="automated">Automated Allocation</TabsTrigger>
      </TabsList>

      {/* Content for the Manual Allocation Tab */}
      <TabsContent value="manual" className="space-y-4">
        {/* Card for the Manual Allocation Form */}
        <Card>
          <CardHeader>
            <CardTitle>Manual Inventory Allocation</CardTitle>
            <CardDescription>Allocate inventory items from suppliers to resources manually</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Display success or error messages from manual allocation attempts */}
            {allocationResult && (
              <Alert variant={allocationResult.success ? "default" : "destructive"}>
                {allocationResult.success ? <CheckCircle2 className="h-4 w-4" /> : <AlertCircle className="h-4 w-4" />}
                <AlertTitle>{allocationResult.success ? "Success" : "Error"}</AlertTitle>
                <AlertDescription>{allocationResult.message}</AlertDescription>
              </Alert>
            )}

            {/* Form Inputs */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {/* Supplier Selection */}
              <div className="space-y-2">
                <Label htmlFor="supplier">Supplier</Label>
                <Select value={selectedSupplier} onValueChange={setSelectedSupplier}>
                  <SelectTrigger id="supplier">
                    <SelectValue placeholder="Select supplier" />
                  </SelectTrigger>
                  <SelectContent>
                    {suppliers.map((supplier) => (
                      <SelectItem key={supplier.id} value={supplier.id.toString()}>
                        {supplier.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Resource Selection */}
              <div className="space-y-2">
                <Label htmlFor="resource">Resource</Label>
                <Select value={selectedResource} onValueChange={setSelectedResource}>
                  <SelectTrigger id="resource">
                    <SelectValue placeholder="Select resource" />
                  </SelectTrigger>
                  <SelectContent>
                    {resources.map((resource) => (
                      <SelectItem key={resource.id} value={resource.id.toString()}>
                        {resource.name}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Inventory Item Selection (filtered by selected supplier) */}
              <div className="space-y-2">
                <Label htmlFor="item">Inventory Item</Label>
                <Select
                  value={selectedItem}
                  onValueChange={setSelectedItem}
                  disabled={!selectedSupplier} // Disable if no supplier is selected
                >
                  <SelectTrigger id="item">
                    <SelectValue placeholder="Select item" />
                  </SelectTrigger>
                  <SelectContent>
                    {inventoryItems
                      // Only show items from the selected supplier that are NOT already allocated
                      .filter((item) =>
                        (!selectedSupplier || item.supplier_id === Number.parseInt(selectedSupplier)) && !item.resource_id
                      )
                      .map((item) => (
                        <SelectItem key={item.id} value={item.id.toString()}>
                          {item.name} ({item.quantity} {item.unit}s available)
                        </SelectItem>
                      ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Quantity Input */}
              <div className="space-y-2">
                <Label htmlFor="quantity">Quantity</Label>
                <Input
                  id="quantity"
                  type="number"
                  min="1"
                  // Add max validation based on selected item quantity? Maybe later.
                  value={quantity}
                  onChange={(e) => setQuantity(e.target.value)}
                />
              </div>
            </div>
          </CardContent>
          <CardFooter>
            {/* Manual Allocation Button */}
            <Button
              onClick={handleManualAllocation}
              // Disable button if allocating or form is incomplete
              disabled={isAllocating || !selectedSupplier || !selectedResource || !selectedItem || !quantity}
              className="w-full"
            >
              {isAllocating ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Allocating...
                </>
              ) : (
                "Allocate Inventory"
              )}
            </Button>
          </CardFooter>
        </Card>

        {/* Card displaying the Current Inventory Table */}
        <Card>
          <CardHeader>
            <CardTitle>Current Inventory</CardTitle>
            <CardDescription>View all inventory items and their current allocation</CardDescription>
          </CardHeader>
          <CardContent>
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead>Item</TableHead>
                  <TableHead>Type</TableHead>
                  <TableHead>Quantity</TableHead>
                  <TableHead>Supplier</TableHead>
                  <TableHead>Allocated Resource</TableHead> {/* Changed header */}
                </TableRow>
              </TableHeader>
              <TableBody>
                {inventoryItems.map((item) => (
                  <TableRow key={item.id}>
                    <TableCell className="font-medium">{item.name}</TableCell>
                    <TableCell>{item.item_type}</TableCell>
                    <TableCell>
                      {item.quantity} / {item.capacity} {item.unit}s
                    </TableCell>
                    <TableCell>{item.supplier_name || "N/A"}</TableCell>
                    <TableCell>
                      {/* Display the allocated resource name or "Unallocated" */}
                      {item.resource_name ? (
                        <Badge variant="outline">{item.resource_name}</Badge>
                      ) : (
                        <Badge variant="secondary">Unallocated</Badge>
                      )}
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </CardContent>
        </Card>
      </TabsContent>

      {/* Content for the Automated Allocation Tab */}
      <TabsContent value="automated" className="space-y-4">
        <Card>
          <CardHeader>
            <CardTitle>Automated Allocation (Optimization)</CardTitle> {/* Changed Title */}
            <CardDescription>Use an algorithm to suggest optimal inventory allocations.</CardDescription> {/* Changed Desc */}
          </CardHeader>
          <CardContent className="space-y-4">
            {/* Explanation of the algorithm */}
            <div className="text-sm text-muted-foreground">
              <p>
                This feature suggests optimal assignments for currently unallocated inventory items to resource locations using the Hungarian algorithm. It considers:
              </p>
              <ul className="list-disc pl-5 mt-2 space-y-1">
                <li>Geographic proximity (Supplier Location to Resource Location)</li>
                <li>Resource capacity utilization</li>
                <li>Low quantity penalty for items</li>
                {/* Remove unsupported criteria for clarity */}
                {/* <li>Supplier capacity and availability</li> */}
                {/* <li>Item type compatibility with resources</li> */}
              </ul>
            </div>

            {/* Display success/error messages from algorithm run/apply */}
             {allocationResult && (
              <Alert variant={allocationResult.success ? "default" : "destructive"}>
                {allocationResult.success ? <CheckCircle2 className="h-4 w-4" /> : <AlertCircle className="h-4 w-4" />}
                <AlertTitle>{allocationResult.success ? "Success" : "Error"}</AlertTitle>
                <AlertDescription>{allocationResult.message}</AlertDescription>
              </Alert>
            )}

            {/* Conditional rendering: Show results table OR the run button */}
            {algorithmResults.length > 0 ? (
              // Display the table of suggested allocations if results exist
              <div className="space-y-4">
                <h3 className="font-medium">Recommended Allocations:</h3>
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>From (Supplier)</TableHead> {/* Clarified header */}
                      <TableHead>To (Resource)</TableHead> {/* Clarified header */}
                      <TableHead>Item</TableHead>
                      <TableHead>Quantity</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {algorithmResults.map((result, index) => (
                      <TableRow key={index}>
                        <TableCell>{result.from}</TableCell>
                        <TableCell>{result.to}</TableCell>
                        <TableCell>{result.item}</TableCell>
                        <TableCell>{result.quantity}</TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>

                {/* Button to apply the suggested allocations */}
                <Button onClick={applyAlgorithmResults} className="w-full">
                  Apply Recommended Allocations
                </Button>
              </div>
            ) : (
              // Show the button to run the algorithm if no results are present
              <Button onClick={runHungarianAlgorithm} disabled={isRunningAlgorithm} className="w-full">
                {isRunningAlgorithm ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Running Optimization...
                  </>
                ) : (
                  "Run Optimization Algorithm"
                )}
              </Button>
            )}
          </CardContent>
        </Card>


      </TabsContent>
    </Tabs>
  )
}

